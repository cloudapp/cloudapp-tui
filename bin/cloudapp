#!/usr/bin/env ruby

require 'cloudapp'
require 'cloudapp/cli'
require 'highline'
require 'ffi-ncurses'

include FFI::NCurses

def config
  CloudApp::CLI::Config.new
end

def account
  require_credentials
  CloudApp::Account.using_token config.token
end

def require_credentials
  return unless config.token.nil?

  $stdout.puts 'Sign into your CloudApp account.'

  email        = HighLine.new.ask('Email: ')
  password     = HighLine.new.ask('Password: ') {|q| q.echo = false }
  config.token = CloudApp::Token.for_account email, password
end

def log(*args)
  File.open('log/curses.txt', 'ab+') do |file|
    file.puts args.inspect
  end
end


def copy(link)
  IO.popen('pbcopy', 'w') {|f| f << link }
end

def draw_drops_window(drops)
  # 1 column wider than necessary to prevent wrapping also accounting for
  # selection indicator.
  width  = drops.map {|drop| drop.name.size }.max + 3
  height = drops.size * 3
  col    = (COLS() - width)  / 2 - 1
  row    = (LINES() - height) / 2 - 1

  wrap = newwin height + 2, width + 2, row, col
  box wrap, 0, 0
  wrefresh wrap

  win = derwin wrap, height, width, 1, 1

  drops.each do |drop|
    drop_lines(drop).each do |line|
      waddstr win, '  '
      waddstr win, line
      waddstr win, "\n"
    end
    waddstr win, "\n"
  end
  wrefresh win

  # Enabling the keypad allows the use of the arrow keys. I don't know why. With
  # the keypad either enabled or disabled the the would-be arrow keys on some
  # keyboard keypads don't work as arrow keys (8=up, 2=down, etc).
  keypad win, true

  [ win, wrap ]
end

def drop_lines(drop)
  details = "  #{ pretty_date(drop.created) } (#{ drop.views })"
  [ drop.name, details ]
end

def select_drop(win, selected_drop, drops)
  # Stay within bounds.
  selected_drop = [ 0,
                    [ drops.size - 1, selected_drop ].min
                  ].max

  line = selected_drop * 3
  mvwaddch win, line, 0, ?>.ord
  wmove win, line, 0

  selected_drop
end

def pretty_date(date)
  diff = (Time.now - date.to_time).to_i
  case diff
    when 0               then 'just now'
    when 1               then 'a second ago'
    when 2..59           then diff.to_s+' seconds ago'
    when 60..119         then 'a minute ago' #120 = 2 minutes
    when 120..3540       then (diff/60).to_i.to_s+' minutes ago'
    when 3541..7100      then 'an hour ago' # 3600 = 1 hour
    when 7101..82800     then ((diff+99)/3600).to_i.to_s+' hours ago'
    when 82801..172000   then 'a day ago' # 86400 = 1 day
    when 172001..518400  then ((diff+800)/(60*60*24)).to_i.to_s+' days ago'
    when 518400..1036800 then 'a week ago'
    else ((diff+180000)/(60*60*24*7)).to_i.to_s+' weeks ago'
  end
end

def popup_window(parent, text)
  text_width  = text.lines.map{ |x| x.size }.max
  text_height = text.lines.to_a.size
  rows, cols  = !parent.nil? ? getmaxyx(parent) : [ LINES(), COLS() ]
  width       = text_width + 4
  height      = text_height + 4
  col         = (cols - width)  / 2
  row         = (rows - height) / 2

  if parent
    frame = derwin parent, height, width, row, col
  else
    frame = newwin height, width, row, col
  end

  werase frame
  box frame, 0, 0

  win = derwin frame, text_height, text_width, 2, 2
  wmove win, 0, 0
  waddstr win, text

  wrefresh frame
  wrefresh win

  if block_given?
    yield
  else
    ch = wgetch win
    log 'popup', ch
    flushinp
    ungetch ch
  end

  delwin win
  delwin frame
end

def show_help(win)
  help = <<-HELP.chomp
j/k = Move down/up
d/p = Next/previous page

c   = Copy share link
C   = Copy embed link
D   = Copy download link
t   = Copy thumbnail link
HELP
  popup_window win, help
  ch = wgetch win
  log 'show_help', ch
  ungetch ch unless ch == ??.ord
end


begin
  initscr
  noecho
  curs_set 0

  drops = nil
  popup_window nil, 'Loading...' do
    drops = account.drops limit: 10
  end

  win, wrap     = draw_drops_window drops
  selected_drop = select_drop win, 0, drops

  while c = wgetch(win)
    log 'wgetch', c
    case c
    when ?q.ord
      break
    when ??.ord
      show_help win

    when ?j.ord, KEY_DOWN
      selected_drop += 1
    when ?k.ord, KEY_UP
      selected_drop -= 1

    when ?d.ord
      next unless drops.link('next') { nil }
      popup_window win, 'Loading...' do
        drops = account.drops href: drops.link('next').href
      end
      wclear   wrap
      wrefresh wrap
    when ?p.ord
      next unless drops.link('previous') { nil }
      popup_window win, 'Loading...' do
        drops = account.drops href: drops.link('previous').href
      end
      wclear   wrap
      wrefresh wrap

    when ?c.ord, KEY_RETURN
      link = drops[selected_drop].share_url
      copy link
      popup_window win, 'Copied share link.'
    when ?C.ord
      link = drops[selected_drop].embed_url
      copy link
      popup_window win, 'Copied embed link.'
    when ?d.ord
      link = drops[selected_drop].download_url
      copy link
      popup_window win, 'Copied download link.'
    when ?t.ord
      link = drops[selected_drop].thumbnail_url
      copy link
      popup_window win, 'Copied thumbnail link.'
    else
      log 'unknown key', c
    end

    delwin win
    delwin wrap
    win, wrap     = draw_drops_window drops
    selected_drop = select_drop win, selected_drop, drops
  end

  delwin win
  delwin wrap

rescue => e
  endwin
  raise
ensure
  endwin
end
